---
layout: writeup
title: 'Binary Exploit 200: Simple Overflow'
level:
difficulty:
points:
categories: []
tags: []
flag:
---
## Challenge

In programming, a buffer overflow is a case where a program, while it is
writing data somewhere, overruns the boundary and begins overwriting
adjacent memory. This is one of the first vulnerabilities used to
exploit software. Modern programming languages tend to provide
protection against this type of vulnerability, but it is still observed
commonly in low-level software.

Buffer overflows can be a complex vulnerability to understand and
exploit due to their low-level nature. To assist you in your training,
we have provided a memory simulation in the middle to help you
understand what happens when your input in the textbox is passed to the
program on the left. The simulation shows you the memory layout of the
underlying process, where your buffer is red, and the secret value is
green. Try entering values into the box and observe how the values that
the program sees change on the left.

In this case, the buffer sits on top of the stack memory, with the
variable secret sitting just below it. As you will observe, the size
limitation placed on buffer is not enforced, allowing you to write more
than 16 characters. Get a feel for buffer overflows by exploring the
above code.

Once you are comfortable with buffer overflows, exploit the program to
grant you the flag.

[overflow.c](writeupfiles/overflow.c)

## Instructions

1.  Hello world!  
    In the textbox in the middle, try entering Hello World!. Observe
    which variable within the code takes the value.

2.  Overflow!  
    What happens if you write more than 16 characters into the buffer?
    Can you make the secret change?

3.  Take control  
    Can you make secret take the value 1633771873 (0x61616161). Note
    that strings are stored in ASCII, and in ASCII, character number
    0x61 is a.

4.  Little endian  
    In most architectures, integers are read in reverse byte order from
    memory, in a method which is called Little endian. Can you make the
    secret take the value 1633837924 (0x61626364)?

5.  Escape from ASCII  
    As you may see in the code, to get past the restrictions and
    retrieve the flag, secret needs to have a value of 0xcafebabe.
    However not all these characters are in ASCII! What will you do?

## Solution

We examine the source code

    #define _GNU_SOURCE
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <sys/types.h>
    
    const char* FLAG = "<REDACTED>"
    
    void flag() {
        printf("FLAG: %s\n", FLAG);
    }
    
    void message(char *input) {
    
        char buf[16] = "";
    
        int secret = 0;
    
        strcpy(buf, input);
    
        printf("You said: %s\n", buf);
    
        if (secret == 0xcafebabe) {
            flag();
        } else {
            printf("The secret is 0x%x\n", secret);
        }
    }
    
    int main(int argc, char **argv) {
        if (argc > 1){
            message(argv[1]);
        } else {
            printf("Usage: ./overflow <message>\n");
        }
        return 0;
    }
{: .language-c}

## Flag

